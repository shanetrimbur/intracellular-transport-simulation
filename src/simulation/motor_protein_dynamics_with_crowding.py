# File: src/simulation/motor_protein_dynamics_with_crowding.py

import numpy as np
import random
import matplotlib.pyplot as plt

# The MotorProtein class models the behavior of motor proteins like kinesin and dynein.
# Motor proteins move along cytoskeletal tracks (microtubules or actin) and transport cargo.
# The movement is driven by ATP hydrolysis, with each step consuming one ATP molecule.
# This class models ATP consumption, stochastic binding, and stepping behavior.
class MotorProtein:
    def __init__(self, name, speed, step_size, force, atp_consumption):
        self.name = name
        self.speed = speed  # Speed of the motor protein (nm/s)
        self.step_size = step_size  # Step size (nm) - typical for kinesin is 8 nm
        self.force = force  # Force generated by the motor protein (pN)
        self.atp_consumption = atp_consumption  # ATP molecules consumed per step
        self.bound = False  # Whether the motor protein is currently bound to a cytoskeletal track
        self.total_atp_used = 0  # Tracks total ATP consumed over the simulation

    def bind_to_track(self, probability):
        """Motor binds to the cytoskeletal track based on a probabilistic model."""
        # The binding follows a stochastic process: the motor binds with a given probability.
        # In biological systems, binding is influenced by factors such as ATP concentration,
        # motor protein affinity, and the presence of regulatory proteins.
        self.bound = random.random() < probability

    def step(self):
        """Simulate one step of motor movement if bound to the track."""
        # Motor proteins move in discrete steps when they are bound to the track.
        # The size of each step is determined by the motor's structural properties (e.g., kinesin moves in 8 nm steps).
        if self.bound:
            return self.step_size
        return 0

    def consume_atp(self):
        """Simulate ATP consumption for each step."""
        # Motor proteins hydrolyze one ATP molecule for each step they take along the track.
        # ATP hydrolysis provides the energy needed to power the motorâ€™s movement.
        # This method tracks ATP consumption and ensures that ATP is used only when the motor is bound.
        if self.bound:
            self.total_atp_used += self.atp_consumption
        return self.atp_consumption if self.bound else 0

# The CytoskeletalTrack class models the cytoskeletal network (microtubules or actin filaments).
# Motor proteins bind to these tracks and move along them.
# In this simplified model, the track is represented as a 1D array.
class CytoskeletalTrack:
    def __init__(self, length):
        self.length = length  # Length of the track (in arbitrary units)
        self.positions = np.zeros(length)  # Array representing motor positions on the track

    def update_position(self, motor, position, direction):
        """Update the position of the motor protein on the track."""
        # Motors can move in either direction along the track (forward or backward),
        # and this movement is reflected in their position.
        # Here, we move the motor by adding or subtracting the step size depending on the direction.
        if 0 <= position < self.length:
            self.positions[position] += motor.step() * direction

# The CytoplasmicCrowding class introduces obstacles into the cytoskeletal track.
# In real cells, the cytoplasm is a crowded environment filled with organelles, proteins, and other molecules.
# This class randomly places obstacles on the track, simulating cytoplasmic crowding.
class CytoplasmicCrowding:
    def __init__(self, track_length, obstacle_count):
        """Randomly distribute obstacles along the cytoskeletal track."""
        # Obstacles are placed at random positions along the track. These obstacles represent
        # the dense environment in the cell, where the movement of motor proteins and cargo
        # can be impeded by other structures (e.g., vesicles, organelles, or protein aggregates).
        self.obstacles = np.random.choice(range(track_length), obstacle_count, replace=False)

    def check_collision(self, position):
        """Check if a motor protein encounters an obstacle at a given position."""
        # If the motor encounters an obstacle, a collision occurs, and we can simulate the
        # effects by changing its direction or stopping its movement temporarily.
        return position in self.obstacles

# This function simulates the intracellular transport with crowding effects.
# It models the tug-of-war dynamics between two types of motor proteins (e.g., kinesin and dynein)
# as they attempt to move cargo along a crowded cytoskeletal track.
def intracellular_transport_simulation_with_crowding(motor1, motor2, steps, track_length, obstacle_count):
    track = CytoskeletalTrack(track_length)  # Initialize the cytoskeletal track
    position = track_length // 2  # Start in the middle of the track
    direction = 1  # Start by moving in one direction (initial assumption)
    crowding = CytoplasmicCrowding(track_length, obstacle_count)  # Add obstacles to the track

    motor1_atp_consumed = []  # Track ATP consumption for motor 1
    motor2_atp_consumed = []  # Track ATP consumption for motor 2

    for step in range(steps):
        motor1.bind_to_track(0.8)  # Stochastic binding with an 80% chance
        motor2.bind_to_track(0.8)

        # Check for collisions with obstacles.
        if crowding.check_collision(position):
            print(f"Step {step + 1}: Collision detected at position {position}, changing direction.")
            direction *= -1  # Reverse direction upon collision (simple reflection model)

        # Update the motor's position along the track.
        track.update_position(motor1, position, direction)
        track.update_position(motor2, position, -direction)  # Motors pulling in opposite directions

        # Simulate ATP consumption by each motor.
        atp_used_motor1 = motor1.consume_atp()
        atp_used_motor2 = motor2.consume_atp()

        motor1_atp_consumed.append(motor1.total_atp_used)
        motor2_atp_consumed.append(motor2.total_atp_used)

        print(f"Step {step + 1}: Motor 1 ATP: {atp_used_motor1}, Motor 2 ATP: {atp_used_motor2}")
        print(f"Motor 1 bound: {motor1.bound}, Motor 2 bound: {motor2.bound}")
        print(f"Position: {position}, Direction: {direction}")

    # Plot the ATP consumption of both motors over time.
    plt.plot(motor1_atp_consumed, label='Motor 1 ATP Consumption (Kinesin)')
    plt.plot(motor2_atp_consumed, label='Motor 2 ATP Consumption (Dynein)')
    plt.xlabel('Simulation Steps')
    plt.ylabel('Total ATP Consumed')
    plt.title('ATP Consumption by Motor Proteins with Crowding')
    plt.legend()
    plt.show()

# Create motor proteins with their respective properties.
kinesin = MotorProtein("Kinesin", 800, 8, 6, 1)  # Kinesin typically moves at ~800 nm/s, 8 nm/step
dynein = MotorProtein("Dynein", 600, 8, 6, 1)  # Dynein typically moves slower than kinesin

# Run the simulation with cytoplasmic crowding.
intracellular_transport_simulation_with_crowding(kinesin, dynein, steps=50, track_length=100, obstacle_count=10)

